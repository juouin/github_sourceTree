<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<script type="text/javascript">
/* 
데이터타입

1. 원시 데이터타입(기본데이터타입) : 숫자,문자열,불리언,null,undefined
2. 객체 데이터타입(참조데이터타입) : 기본을 제외한 나머지
*/

var str = 'coding';			//문자열 
str.prop = 'everybody';		//내부적으로 객체로 인식(에러는없지만)
console.log(str.prop);	//undefined		막상 출력하려고하면 값이 없는걸로 인식됨

//wrapper 객체 : 원시데이터타입이있을때, 그것을 감싸주는 객체 ==> 이렇게 처리가 되면 하나의 객체로 인식이된다
/*
원시데이터타입을 감싸주는 wrapper객체
숫자			→→ Number		
문자열		→→ String
불리언		→→ Boolean
null		→→ X
undefined	→→ X
*/

// 참조 -----------------------------------------------------------------------------

//복제 : 전자화된 시스템 위의 데이터는 복제하는데 비용이 거의 들지않는다.
var a = 1;	//원시데이터타입
var b = a;	//복제가 일어남
b= 2;		//복제된 데이터를 참조함
console.log(a);	//1

//참조(reference)  
var c = {'id':1};	//객체데이터타입
var d = c;			//복제가 되지않고, c가 참조하던객체를 d도 참조하게된다(c,d는 똑같은 객체를 바라보게된다)
d.id = 2;
console.log(c.id);	//2 => d의 속성(프로퍼티)을 변경했는데 c의 속성값도 바뀌어버렸다 

var c = {'id':1};	
var d = c;			
d = {'id':2};		//이런식으로 d의 속성을 재할당해버리면 d는 더이상 {'id':1}를 바라보지않고, {'id':2}를 바라보게됨
console.log(c.id);	//1 

// 함수 -------------------------------------------------------------------------------

// 원시 데이터타입을 인자로 넘겼을때
var one = 1;
function func(two) {	//one의 값이 복제!되어서 two값에 담기게된다.(one값에는 어떠한 영향도 주지않는다)
	two = 2;
}
func(one);
console.log(one);	//1


// 참조 데이터타입을 인자로 넘겼을때
var e = {'id':1};	//변수에 담긴값이 객체이다
function fu(f) {	// f = e;	서로 같은 객체를 바라본다
	f = {'id':2};	// f가 새로운 객체를 만들었다. (서로 영향을 주지않는다)
}
fu(e);
console.log(e.id);	//1

// 참조 데이터타입 두번째예시
var g = {'id':1};	
function fuzz(h) {	// h = g;	서로 같은 객체를 바라본다
	h.id = 2;	  	// h가 g와같이 바라보던 객체를 수정했다.
}
fuzz(g);
console.log(g.id);	//2

</script>
</head>
<body>

</body>
</html>